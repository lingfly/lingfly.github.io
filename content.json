{"meta":{"title":"lingfly's blog","subtitle":"记录学习和生活的点点滴滴","description":"读的书太少，却想的太多。","author":"lingfly","url":"https://www.zlingfly.com"},"pages":[{"title":"关于我自己","date":"2017-10-21T03:03:34.000Z","updated":"2018-05-15T21:28:33.781Z","comments":true,"path":"about/index.html","permalink":"https://www.zlingfly.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-19T11:34:08.000Z","updated":"2018-05-15T21:28:33.704Z","comments":true,"path":"categories/index.html","permalink":"https://www.zlingfly.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-19T11:33:01.000Z","updated":"2018-05-15T21:28:33.446Z","comments":true,"path":"tags/index.html","permalink":"https://www.zlingfly.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"合工大OJ_1377_A?H?","slug":"合工大OJ-1376-A-H","date":"2018-05-12T14:49:28.000Z","updated":"2018-05-15T21:28:32.753Z","comments":true,"path":"2018/05/12/合工大OJ-1376-A-H/","link":"","permalink":"https://www.zlingfly.com/2018/05/12/合工大OJ-1376-A-H/","excerpt":"","text":"题目描述Description目前图像识别是一项非常热门的技术，最流行莫不过是深度学习，识率甚至能达到 99% 以上。当然，对于简单的图像来说深度学习是没有 必要的。比如要识别安徽拼音首字母 A和 H，就可以不用深度学习就可以判断。现在有一些只含 A或者 H的图像，你知道该如何识别吗？ 第一行输入 正整数 T，表示数据的组。每组数 据中，第一行是两个正整n和 m，表示图像的大小。接下来有 n行 ，每行 ，每m个字符，只可能为 个字符，只可能为 个字符，只可能为 个字符，只可能为 ‘.’ 或者 ‘#’ 。’.’ 表示白色， ‘#’ 表 示黑色。 ‘#’ 会通过上下左右或者连成一个区域，该表示 会通过上下左右或者连成一个区域，该表示 字母。 题目链接http://acm.hfut.edu.cn/OnlineJudge/ 题解额。。。那啥。。一般情况下遇到这种题目是要用连通块的，但是这一题有些蹊跷，因为A是封闭的，也就是说用dfs搜是搜不完的，而H能搜完。所以dfs遍历一次，如果有点没搜到，那字母就是A，反之是H。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt; #include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int maxn=110;int ma[maxn][maxn];int vis[maxn][maxn];int pre[][2]=&#123;0,-1,0,1,-1,0,1,0&#125;;//前进方向的数组int n,m;void dfs(int x,int y);bool check(int x,int y);//检查边界int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int t,Case=1; cin&gt;&gt;t; while(t--)&#123; memset(vis,0,sizeof(vis)); int i,j; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; char c; cin&gt;&gt;c; if(c=='.') ma[i][j]=0; else ma[i][j]=1; &#125; &#125; //从两个边界点开始搜，确保所有外围都能搜到 dfs(0,0); dfs(n+1,m+1); int flag=0; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; if(ma[i][j]==0)&#123; flag=1; break; &#125; &#125; &#125; if(flag)&#123; cout&lt;&lt;\"Case \"&lt;&lt;Case&lt;&lt;\": A\\n\"; &#125; else cout&lt;&lt;\"Case \"&lt;&lt;Case&lt;&lt;\": H\\n\"; Case++; &#125; return 0;&#125;void dfs(int x,int y)&#123; if(!check(x,y))return; if(ma[x][y]==0)ma[x][y]=2; vis[x][y]=1; for(int i=0;i&lt;4;i++)&#123; int xx=x+pre[i][0]; int yy=y+pre[i][1]; if(!check(xx,yy))continue; dfs(xx,yy); &#125;&#125;bool check(int x,int y)&#123; if(x&lt;0||x&gt;n+1||y&lt;0||y&gt;m+1||ma[x][y]==1||vis[x][y]) return false; else return true;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.zlingfly.com/tags/DFS/"},{"name":"华信智原杯","slug":"华信智原杯","permalink":"https://www.zlingfly.com/tags/华信智原杯/"}]},{"title":"合工大OJ_1376_版本依赖","slug":"合工大OJ-1376-版本依赖","date":"2018-05-12T14:34:59.000Z","updated":"2018-05-15T21:28:32.651Z","comments":true,"path":"2018/05/12/合工大OJ-1376-版本依赖/","link":"","permalink":"https://www.zlingfly.com/2018/05/12/合工大OJ-1376-版本依赖/","excerpt":"","text":"题目描述Description在项目开发的过程中，会经常使用别人打包好的项目以简化工作。别人的项目也有它们的版本号，我们所依赖的项目需要对其版本号进行一些限制，所以项目的根目录一般会有一个文件存储该项目的依赖情况，以便程序员主动解决依赖问题，或者由某些包管理工具自动下载正确的依赖。 现在给你某个项目的依赖，以及当前电脑里已经存在的项目的版本号的列表，问你当前依赖是否存在问题？ 依赖文件每行代表一个依赖，由依赖名称，依赖关系，依赖项目的版本号三部分组成。依赖名称只由小写字母组成，名称最长为10个字母。依赖关系为’==’,’&lt;’,’&gt;’,’&lt;=’,’&gt;=’这五种的某一种，版本号由三部分组成格式为：&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修订版本号&gt;，如1.0.0，版本号为非负整数且小于100。两个版本号的比较，依次根据主版本号，次版本号，修订版本号之间的数字大小关系来确定两个版本号的大小关系。 如某个项目A的依赖如下： apple==1.0.0 banana&gt;=2.3.3 celery&lt;4.0.0 这表示A项目依赖于apple，banana，celery这三个项目，对其分别的要求是：apple的版本号必须为1.0.0，banana的版本号至少为2.3.3，celery的版本号必须小于4.0.0。 题目链接http://acm.hfut.edu.cn/OnlineJudge/ 题解这就是一道模拟题，我一开始打算把版本号的三个数化成一个大整数比较，结果发现有些数据是一位数有些是两位，比较的时候会出错，所以只能对三个数分别进行比较。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn=110;using namespace std;int cmp(int* x, int* y);int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int t,Case=1; cin&gt;&gt;t; while(t--)&#123; int n,m,flag[maxn]; memset(flag,0,sizeof(flag)); cin&gt;&gt;n; string s,a[maxn],b[maxn]; int c[maxn][10]; //将输入分为依赖，符号，版本号三部分 for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; a[i]=\"\",b[i]=\"\",c[i][0]=0; int j=0; while(s[j]&gt;='a'&amp;&amp;s[j]&lt;='z')&#123; a[i]+=s[j]; j++; &#125; while(s[j]&gt;'9'||s[j]&lt;'0')&#123; b[i]+=s[j]; j++; &#125; int len=s.size(); int bi=0; for(int k=j;k&lt;len;k++)&#123; if(s[k]&gt;='0'&amp;&amp;s[k]&lt;='9')&#123; c[i][bi]=c[i][bi]*10+s[k]-'0'; &#125; else&#123; bi++; c[i][bi]=0; &#125; &#125; &#125; cin&gt;&gt;m; while(m--)&#123; string s,t; int num[10]=&#123;0&#125;; cin&gt;&gt;s&gt;&gt;t; int len=t.size(); int ti=0; for(int k=0;k&lt;len;k++)&#123; if(t[k]&gt;='0'&amp;&amp;t[k]&lt;='9')&#123; //cout&lt;&lt;t[k]-'0'; num[ti]=num[ti]*10+t[k]-'0'; &#125; else&#123; ti++; num[ti]=0; &#125; &#125; int index=0; while(index&lt;n&amp;&amp;s!=a[index])&#123; index++; &#125; if(index&lt;n)&#123; //cout&lt;&lt;\"b\"&lt;&lt;b[index]&lt;&lt;endl; if(b[index]==\"&gt;=\"&amp;&amp;(cmp(num,c[index])==1||cmp(num,c[index])==0)) flag[index]=1; else if(b[index]==\"&gt;\"&amp;&amp;(cmp(num,c[index])==1)) flag[index]=1; else if(b[index]==\"==\"&amp;&amp;(cmp(num,c[index])==0)) flag[index]=1; else if(b[index]==\"&lt;\"&amp;&amp;(cmp(num,c[index])==-1)) flag[index]=1; else if(b[index]==\"&lt;=\"&amp;&amp;(cmp(num,c[index])==-1||cmp(num,c[index])==0)) flag[index]=1; &#125; &#125; int f=0; cout&lt;&lt;\"Case \"&lt;&lt;Case&lt;&lt;\": \"; for(int i=0;i&lt;n;i++)&#123; if(flag[i]==0)&#123; if(f==1)cout&lt;&lt;' '; cout&lt;&lt;a[i]; f=1; &#125; &#125; if(f==0)cout&lt;&lt;\"OK\"; cout&lt;&lt;endl; Case++; &#125; return 0;&#125;int cmp( int* x, int* y)&#123;//对两个版本号进行比较 if(x[0]&gt;y[0])return 1; else if(x[0]==y[0])&#123; if(x[1]&gt;y[1])return 1; else if(x[1]==y[1])&#123; if(x[2]&gt;y[2])return 1; else if(x[2]==y[2])return 0; else return -1; &#125; else return -1; &#125; else return -1;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"华信智原杯","slug":"华信智原杯","permalink":"https://www.zlingfly.com/tags/华信智原杯/"}]},{"title":"合工大OJ_1372_找零","slug":"合工大OJ-1372-找零","date":"2018-05-12T14:19:35.000Z","updated":"2018-05-15T21:28:32.581Z","comments":true,"path":"2018/05/12/合工大OJ-1372-找零/","link":"","permalink":"https://www.zlingfly.com/2018/05/12/合工大OJ-1372-找零/","excerpt":"","text":"题目描述Description超市收银台出了故障,需要帮忙完成收银和找零的工作,如果顾客买的东西的总价值含有”分”,就进位计算.如:购买了总价值9.91元的物品,收到20元,应找零10元整.如钱不够，输出-1 Input第一行输入正整数T，表示数据的组数。每组数据的第一行是购买的物品的种类数n 和顾客给的钱的总数m(顾客给的钱不会有”分”),接下来有n行[1,100],每行两个数字,第一个数字是该物品的价格Pi([0.01,10000]),第二个数字是该物品的数量Ci([1,10])。 Output对于每组数据，输出一行，格式为’Case t: x’，t 为数据的组号，x 为题目要求的结果。 Sample Input3 5 200.00 9.99 1 8.88 1 0.50 1 1.00 1 2.33 3 1 10.00 9.99 1 2 100.00 98.99 1 1.02 1 Sample OutputCase 1: 172.60 Case 2: 0.00 Case 3: -1 题目链接http://acm.hfut.edu.cn/OnlineJudge/ 题解题目要求把物品总价值的‘分’进位，思路大概就是把总价值乘以100，然后就相当于如果个位不为0就进位。 思路超级简单是不是？但是这题最坑的地方就是总价值*100会爆int。。。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std;typedef long long LL;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int t; scanf(\"%d\",&amp;t); int cas=1; while(t--)&#123; LL n; double all=0.0; double sum=0.0,m=0.0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; double x; double c; cin&gt;&gt;x&gt;&gt;c; all=all+(x*c*100); &#125; LL a=(int)all%10; if(a!=0)&#123; all=all+10-a; &#125; sum=all/100; if(m&gt;=sum) printf(\"Case %d: %.2f\\n\",cas,m-sum); else &#123; printf(\"Case %d: -1\\n\",cas); &#125; cas++; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"华信智原杯","slug":"华信智原杯","permalink":"https://www.zlingfly.com/tags/华信智原杯/"}]},{"title":"五子棋棋型和术语","slug":"五子棋棋型和术语","date":"2018-05-08T12:40:26.000Z","updated":"2018-05-15T21:28:33.244Z","comments":true,"path":"2018/05/08/五子棋棋型和术语/","link":"","permalink":"https://www.zlingfly.com/2018/05/08/五子棋棋型和术语/","excerpt":"","text":"〖五连〗只有五枚同色棋子在一条阳线或阴线上相邻成一排。 〖成五〗含有五枚同色棋子所形成的连，包括五连和长连。 〖四〗在一条阳线或阴线上连续相邻的5个点上只有四枚同色棋子的棋型。 〖活四〗有两个点可以成五的四。 〖冲四〗只有一个点可以成五的四。 〖死四〗不能成五的四。 〖三〗在一条阳线或阴线上连续相邻的5个点上只有三枚同色棋子的棋型。 〖活三〗再走一着可以形成活四的三。 〖连活三〗即：连的活三（同色棋子在一条阳线或阴线上相邻成一排的活三）。简称“连三”。 〖跳活三〗中间隔有一个空点的活三。简称“跳三”。 〖眠三〗再走一着可以形成冲四的三。 〖死三〗不能成五的三。 〖二〗在一条阳线或阴线上连续相邻的5个点上只有两枚同色棋子的棋型。 〖活二〗再走一着可以形成活三的二。 〖连活二〗即：连的活二（同色棋子在一条阳线或阴线上相邻成一排的活二）。简称“连二”。 〖跳活二〗中间隔有一个空点的活二。简称“跳二”。 〖大跳活二〗中间隔有两个空点的活二。简称“大跳二”。 〖眠二〗再走一着可以形成眠三的二。 〖死二〗不能成五的二。","categories":[],"tags":[{"name":"五子棋","slug":"五子棋","permalink":"https://www.zlingfly.com/tags/五子棋/"}]},{"title":"Java实现五子棋","slug":"Java实现五子棋","date":"2018-05-08T09:41:17.000Z","updated":"2018-05-15T21:28:33.271Z","comments":true,"path":"2018/05/08/Java实现五子棋/","link":"","permalink":"https://www.zlingfly.com/2018/05/08/Java实现五子棋/","excerpt":"","text":"主要内容1.使用Java swing实现五子棋界面2.五子棋对弈3.五子棋AI的实现(这里用的只是简单的权值法) 效果预览界面效果如图，AI的水平大概跟一些五子棋APP的入门级别差不多 实践过程1.首先是界面的绘制123456789101112131415161718192021222324252627282930313233343536373839404142public void paintComponent(Graphics g)&#123; super.paintComponent(g); //画棋盘的行和列 for(int i=0;i&lt;ROW;i++)&#123;//列 g.drawLine(MARGIN+interval*i,MARGIN,MARGIN+interval*i,MARGIN+interval*(COL-1)); &#125; for(int i=0;i&lt;COL;i++)&#123;//行 g.drawLine(MARGIN,MARGIN+interval*i,MARGIN+interval*(ROW-1),MARGIN+interval*i); &#125; //画棋子 int i=0; int count=chessList.size(); for(Point p:chessList)&#123; int x=p.getX()*interval+MARGIN; int y=p.getY()*interval+MARGIN; RadialGradientPaint paint; if(p.getColor()==Color.BLACK)&#123; //这里是使用渐变渲染来绘制棋子 paint =new RadialGradientPaint(x+Point.radius/2, y-Point.radius/2, 18 , new float[]&#123;0f, 1f&#125; , new Color[]&#123;Color.WHITE, Color.BLACK&#125;); &#125; else&#123; paint =new RadialGradientPaint(x+Point.radius/2, y-Point.radius/2, 70 , new float[]&#123;0f, 1f&#125; , new Color[]&#123;Color.WHITE, Color.BLACK&#125;); &#125; Graphics2D g2=(Graphics2D)g; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);//抗锯齿 g2.setPaint(paint); Ellipse2D circle=new Ellipse2D.Double(x-Point.radius,y-Point.radius,Point.radius*2,Point.radius*2); g2.fill(circle); i++; if(i==count)&#123;//给最后一个棋子加一个红框 g.setColor(Color.RED); g.drawRect(x-Point.radius,y-Point.radius,Point.radius*2,Point.radius*2); &#125; &#125; &#125; 以上是界面的绘制，大部分是swing的常见应用，比较少见的就是环形渐变渲染和抗锯齿，直接百度搜其类名可以找到用法。 2.对弈部分Java写对弈部分其实挺简单的，就是写个鼠标事件，鼠标单击则在棋盘上落子，我这里用的是MouseListener类需要把里面所有的方法重写一遍，如果不想这么麻烦的话可以用适配器类MouseAdapter。12345678910111213141516171819int player=isBlack?1:2; int xIndex=(e.getX()-MARGIN+interval/2)/interval;//计算落子所在行和列 int yIndex=(e.getY()-MARGIN+interval/2)/interval; //如果游戏结束或点击不在棋盘范围内则无法落子 if(!check(xIndex,yIndex)||map[xIndex][yIndex]!=0||gameover==1)return; Point ch=new Point(xIndex,yIndex,isBlack?Color.BLACK:Color.WHITE); chessList.add(ch); if(isBlack)map[xIndex][yIndex]=1; else map[xIndex][yIndex]=2; if(isWin(player,xIndex,yIndex))&#123; if(isBlack) System.out.printf(\"黑方胜\\n\"); else System.out.printf(\"白方胜\\n\"); gameover=1; &#125; isBlack=!isBlack; repaint(); if(gameover==1)return ; 还有判断赢棋的方法 123456789101112131415161718192021222324boolean isWin(int play,int x,int y)&#123; int[] link=&#123;1,1,1,1&#125;; for(int i=0;i&lt;4;i++)&#123; //对 上，右上，右，右下 及其反方向搜索是否有五子相连 int xx=x+dir[i][0]; int yy=y+dir[i][1]; while(check(xx,yy)&amp;&amp;map[xx][yy]==play)&#123; link[i]++; xx=xx+dir[i][0]; yy=yy+dir[i][1]; &#125; xx=x-dir[i][0]; yy=y-dir[i][1]; while(check(xx,yy)&amp;&amp;map[xx][yy]==play)&#123; link[i]++; xx=xx-dir[i][0]; yy=yy-dir[i][1]; &#125; &#125; for(int i=0;i&lt;4;i++)&#123; if(link[i]&gt;=5)return true; &#125; return false; &#125; 3.AI的实现这里AI的实现难点主要是各种棋型的判断首先，可以根据这篇文章来了解一下五子棋的主要术语和棋型棋型 判断棋型的方法参考了这篇文章判断棋型12int[] lchess=new int[]&#123;0,0&#125;,rchess=new int[]&#123;0,0&#125;;int[] lempty=new int[]&#123;0,0&#125;,rempty=new int[]&#123;0,0&#125;; lchess[0] 表示 (y, x) 左边的且与 (y, x) 相连的连续同类棋数目， lempty[0] 表示从 (y, x) 左边第一个空点数起的连续空点数目， lchess[1] 表示 (y, x) 左边的且与 (y, x) 至少隔一个空点的连续同类棋数目， lempty[1] 表示在 lchess[1] 个同类棋左边的连续空点数目， 通过这四个数组判断一个空位四个方向的连子和空位情况，进而通过这些信息判断棋型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void CalChess(int play,Point po,int d1,int d2)&#123; //判断玩家play在po位置的棋型 int x=po.getX(); int y=po.getY(); int i,j,mid=0; int[] lchess=new int[]&#123;0,0&#125;,rchess=new int[]&#123;0,0&#125;; int[] lempty=new int[]&#123;0,0&#125;,rempty=new int[]&#123;0,0&#125;; i=x-d1;j=y-d2; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==play)&#123; lchess[0]++; i -= d1; j -= d2;&#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==0)&#123; lempty[0]++; i -= d1; j -= d2; &#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==play)&#123; lchess[1]++; i -= d1; j -= d2; &#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==0)&#123; lempty[1]++; i -= d1; j -= d2; &#125; i=x+d1;j=y+d2; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==play) &#123; rchess[0]++; i += d1; j += d2; &#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j] == 0) &#123; rempty[0]++; i += d1; j += d2; &#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j]==play) &#123; rchess[1]++; i += d1; j += d2; &#125; while(ChessBoard.check(i,j)&amp;&amp;map[i][j] == 0) &#123; rempty[1]++; i += d1; j += d2; &#125; mid=lchess[0]+rchess[0]+1; if(mid&gt;=5)po.g5++;//成五 else if(mid==4)&#123; if(lempty[0]&gt;=1&amp;&amp;rempty[0]&gt;=1)po.live4++;//活四 else if(lempty[0]&gt;=1||rempty[0]&gt;=1)po.c4++;/冲四 else po.dead4++;//死四 &#125; else if(mid==3)&#123; boolean flag=false;//有冲四则放弃活三 if((lempty[0]==1&amp;&amp;lchess[0]&gt;=1)||(rempty[0]==1&amp;&amp;rchess[0]&gt;=1))&#123; po.rc4++; flag=true; &#125; else if(!flag&amp;&amp;lempty[0]+rempty[0]&gt;=3&amp;&amp;lempty[0]&gt;=1&amp;&amp;rempty[0]&gt;=1)&#123; po.live3++; &#125; else if(lempty[0]&gt;=1||rempty[0]&gt;=1)&#123;//眠三 po.m3++; &#125; else po.dead3++; &#125; else if(mid==2)&#123; boolean flag=false; if(lempty[0]==1&amp;&amp;lchess[1]&gt;=2||rempty[0]==1&amp;&amp;rchess[1]&gt;=2)&#123; po.rc4++; flag=true; &#125; else if(!flag&amp;&amp;(lempty[0]==1&amp;&amp;lchess[1]==1&amp;&amp;rempty[0]&gt;=1&amp;&amp;lempty[1]&gt;=1) ||(rempty[0]==1&amp;&amp;rchess[1]==1&amp;&amp;lempty[0]&gt;=1&amp;&amp;rempty[1]&gt;=1))&#123; po.rlive3++; &#125; else if((lempty[0] == 1 &amp;&amp; lchess[1] == 1 &amp;&amp; rempty[0] + lempty[1] &gt;= 1) || (rempty[0] == 1 &amp;&amp; rchess[1] == 1 &amp;&amp; lempty[0] + rempty[1] &gt;= 1))&#123; po.m3++; &#125; if(lempty[0] + rempty[0] &gt;= 4 &amp;&amp; lempty[0] &gt;= 1 &amp;&amp; rempty[0] &gt;= 1) po.live2++; else if(lempty[0] + rempty[0] == 0) po.dead2++; &#125; else if(mid == 1)&#123; boolean flag = false; if((lempty[0] == 1 &amp;&amp; lchess[1] &gt;= 3) || (rempty[0] == 1 &amp;&amp; rchess[1] &gt;= 3))&#123; po.rc4++; flag = true; &#125; if(!flag &amp;&amp; ((lempty[0] == 1 &amp;&amp; lchess[1] == 2 &amp;&amp; rempty[0] &gt;= 1 &amp;&amp; lempty[1] &gt;= 1) || (rempty[0] == 1 &amp;&amp; rchess[1] == 2 &amp;&amp; lempty[0] &gt;= 1 &amp;&amp; rempty[1] &gt;= 1)))&#123; po.rlive3++; &#125; else if((lempty[0] == 1 &amp;&amp; lchess[1] == 2 &amp;&amp; rempty[0] + lempty[1] &gt;= 1) || (rempty[0] == 1 &amp;&amp; rchess[1] == 2 &amp;&amp; lempty[0] + rempty[1] &gt;= 1)) po.m3++; if((lempty[0] == 1 &amp;&amp; lchess[1] == 1 &amp;&amp; rempty[0] + lempty[1] &gt;= 3 &amp;&amp; rempty[0] &gt;= 1 &amp;&amp; lempty[1] &gt;= 1) || (rempty[0] == 1 &amp;&amp; rchess[1] == 1 &amp;&amp; rempty[1] + lempty[0] &gt;= 3 &amp;&amp; lempty[0] &gt;= 1 &amp;&amp; rempty[1] &gt;= 1))&#123; po.rlive2++; &#125; if((lempty[0] == 2 &amp;&amp; lchess[1] == 1 &amp;&amp; rempty[0] &gt;= 1 &amp;&amp; lempty[1] &gt;= 1) || (rempty[0] == 2 &amp;&amp; rchess[1] == 1 &amp;&amp; lempty[0] &gt;= 1 &amp;&amp; rempty[1] &gt;= 1))&#123; po.rlive2++; &#125; &#125;&#125; 完最后，由于代码太长没有全贴出来，所以直接复制是不能运行的 完整的项目在这里https://github.com/lingfly/my_gobang#my_gobangng","categories":[{"name":"Java","slug":"Java","permalink":"https://www.zlingfly.com/categories/Java/"}],"tags":[{"name":"五子棋","slug":"五子棋","permalink":"https://www.zlingfly.com/tags/五子棋/"},{"name":"Java","slug":"Java","permalink":"https://www.zlingfly.com/tags/Java/"}]},{"title":"在Ubuntu中搜索文件","slug":"在Ubuntu中搜索文件","date":"2018-03-05T19:30:43.000Z","updated":"2018-05-15T21:28:32.163Z","comments":true,"path":"2018/03/06/在Ubuntu中搜索文件/","link":"","permalink":"https://www.zlingfly.com/2018/03/06/在Ubuntu中搜索文件/","excerpt":"","text":"1.whereis +文件名用于程序名的搜索，搜索结果只限于二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s），如果省略参数，则返回所有信息。 2.find +目录 -name +文件名find是在指定的目录下遍历查找，如果目录使用 / 则表示在所有目录下查找，find方式查找文件消耗资源比较大，速度也慢一点。 3.lacate +文件名linux会把系统内所有的文件都记录在一个数据库文件中，使用locate+文件名的方法会在linux系统维护的这个数据库中去查找目标，相比find命令去遍历磁盘查找的方式，效率会高很多，比较推荐使用这种方法。 4. which +文件名which的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.zlingfly.com/categories/笔记/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.zlingfly.com/tags/ubuntu/"}]},{"title":"好记性不如烂笔头","slug":"好记性不如烂笔头","date":"2018-01-27T15:30:31.000Z","updated":"2018-05-15T21:28:33.155Z","comments":true,"path":"2018/01/27/好记性不如烂笔头/","link":"","permalink":"https://www.zlingfly.com/2018/01/27/好记性不如烂笔头/","excerpt":"","text":"我觉得遇到什么问题解决了还是要记一下的，不然下次遇到还得GG 博客从今天多开了笔记这一分类 所以说，好记性不如烂博客？","categories":[{"name":"diary","slug":"diary","permalink":"https://www.zlingfly.com/categories/diary/"}],"tags":[]},{"title":"ubuntu使用Java图形界面捕捉到异常","slug":"ubuntu使用Java图形界面捕捉到异常","date":"2018-01-27T15:19:44.000Z","updated":"2018-05-15T21:28:33.096Z","comments":true,"path":"2018/01/27/ubuntu使用Java图形界面捕捉到异常/","link":"","permalink":"https://www.zlingfly.com/2018/01/27/ubuntu使用Java图形界面捕捉到异常/","excerpt":"","text":"libXtst.so.6: cannot open shared object file: No such file or directory 由这句就能看出少了个包 我并不知道少了这个包该怎么办，不过没关系，百度就好了 问题解决： sudo apt-get install libxtst6:i386","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.zlingfly.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.zlingfly.com/tags/java/"}]},{"title":"状态压缩一","slug":"状态压缩一","date":"2018-01-21T12:22:51.000Z","updated":"2018-05-15T21:28:32.219Z","comments":true,"path":"2018/01/21/状态压缩一/","link":"","permalink":"https://www.zlingfly.com/2018/01/21/状态压缩一/","excerpt":"","text":"hihocoder #1044状态压缩·一数学渣做这种偏分析的题是真的绝望，我就不多说了，该说的题目提示里面都有 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1050;int cn[1050] = &#123; 0,1,1 &#125;;int dp[2][maxn];int main() &#123; //freopen(\"in.txt\", \"r\", stdin); int n, m, q; int i, j; for (i = 3; i &lt;= 1024; i++) &#123; cn[i] = cn[i &gt;&gt; 1] + (i &amp; 1); //预处理每个数有多少个1 //cout &lt;&lt; cn[i] &lt;&lt; ' '; &#125; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123; memset(dp, 0, sizeof(dp)); int w[maxn]; for (i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for (i = 1; i &lt;= n; i++) &#123; for (j = 0; j &lt; (1 &lt;&lt; m); j++) &#123; if (cn[j] &lt;= q) &#123; dp[i &amp; 1][j] = max(dp[~i &amp; 1][j&gt;&gt; 1], dp[~i &amp; 1][(j &gt;&gt; 1) + (1 &lt;&lt; (m-1))]) + w[i] * (j &amp; 1); //如果j最后一位为1，dp[i &amp; 1][j] = max(上一位取0，上一位取1的最大垃圾量+当前位置的垃圾量） //如果j最后一位为0，dp[i &amp; 1][j] = max(上一位取0，上一位取1的最大垃圾量) //cout &lt;&lt; \"w=\" &lt;&lt; w[i] * (j &amp; 1) &lt;&lt; endl; &#125; //cout &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; //printf(\"dp[%d][%d]=%d\\n\", i &amp; 1, j, dp[i &amp; 1][j]); &#125; &#125; //cout &lt;&lt; \"gg\" &lt;&lt; endl; int ans = 0; for (i = 1; i &lt;= (1&lt;&lt;m); i++) ans = max(ans, dp[n &amp; 1][i]); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"状态压缩dp","slug":"状态压缩dp","permalink":"https://www.zlingfly.com/tags/状态压缩dp/"}]},{"title":"区间更新区间求和","slug":"区间更新区间求和","date":"2018-01-21T11:27:49.000Z","updated":"2018-05-15T21:28:32.210Z","comments":true,"path":"2018/01/21/区间更新区间求和/","link":"","permalink":"https://www.zlingfly.com/2018/01/21/区间更新区间求和/","excerpt":"","text":"POJ.3468 A Simple Problem with Integers题目大意给n个数的数组和q个指令 指令Q，计算[a,b]范围内数的和 指令C，将[a,b]范围内的数加上c 数据范围： The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. 题解就是简单的区间更新区间求和，只是数据过大，要用线段树解决，不过据说用树状数组的的老司机可以不用laxyTag（什么是laxyTag自己百度），但是我太菜了，只能按部就班的写 代码我写的线段树好像计算量有点大，比较慢，而且我用cin输入，所以必须关同步 至于我为什么明知道cin慢我还要用？这还用说，当然是因为我懒啊 还有一点，Ai的范围比较大，得到的sum值要用long long 关于读入速度，这里大佬有个小测试，不了解的不妨去看看 ios::sync_with_stdio(false); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define maxn 100010typedef long long ll;using namespace std;ll a[maxn], n, q;struct node &#123; ll l, r, sum, tag;&#125;tr[maxn * 4];void build(int id, int l, int r);void change(int id, int ql, int qr, int lazyTag);ll query(int id, int ql, int qr);void pushdown(int id);int main() &#123; ios::sync_with_stdio(false);//关同步 //freopen(\"in.txt\",\"r\",stdin); cin &gt;&gt; n&gt;&gt;q; int i; for (i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (q--) &#123; char o; cin &gt;&gt; o; if (o == 'Q') &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; query(1, a, b) &lt;&lt; endl; &#125; if (o == 'C') &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; //cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; change(1, a, b, c); &#125; &#125; return 0;&#125;void build(int id, int l, int r) &#123;//建立线段树 tr[id].l = l; tr[id].r = r; tr[id].tag = 0; //初始化节点的边界和tag if (l == r) &#123; tr[id].sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid);//建立左子树 build(id &lt;&lt; 1 | 1, mid + 1, r);//建立右子树 tr[id].sum = tr[id &lt;&lt; 1].sum + tr[id &lt;&lt; 1 | 1].sum;&#125;void change(int id, int ql, int qr, int lazyTag) &#123;//区间更新 int l = tr[id].l, r = tr[id].r; if (l &gt;= ql&amp;&amp;r &lt;= qr) &#123;//当节点的范围被查询范围所包含，就结束递归 tr[id].sum += (r - l + 1)*lazyTag; tr[id].tag += lazyTag; return; &#125; pushdown(id); if (ql &lt;= tr[id &lt;&lt; 1].r)//左子树范围和查询范围相交，就向左子树搜索 change(id &lt;&lt; 1, ql, qr, lazyTag); if (qr &gt;= tr[id &lt;&lt; 1 | 1].l)//右子树范围和查询范围相交，就向右子树搜索 change(id &lt;&lt; 1 | 1, ql, qr, lazyTag); tr[id].sum = tr[id &lt;&lt; 1].sum + tr[id &lt;&lt; 1 | 1].sum;&#125;ll query(int id, int ql, int qr) &#123;//区间查询和区间更新差不多 int l = tr[id].l, r = tr[id].r; if (ql &lt;= l&amp;&amp;qr &gt;= r) &#123; return tr[id].sum; &#125; pushdown(id); int mid = (l + r) / 2; ll p1 = 0, p2 = 0; if (ql &lt;= mid) p1 += query(id &lt;&lt; 1, ql, qr); if (qr&gt;mid) p2 += query(id &lt;&lt; 1 | 1, ql, qr); tr[id].sum = tr[id &lt;&lt; 1].sum + tr[id &lt;&lt; 1 | 1].sum; return p1 + p2;&#125;void pushdown(int id) &#123; //这个pushdown，大概就是遍历到一个节点时， //如果tag不为0（即节点被标记过），就处理这个节点的tag int l = tr[id].l, r = tr[id].r; if (tr[id].tag != 0) &#123; int mid = (l + r) / 2; tr[id &lt;&lt; 1].sum += (mid - l + 1)*tr[id].tag; tr[id &lt;&lt; 1 | 1].sum += (r - mid)*tr[id].tag; tr[id &lt;&lt; 1].tag += tr[id].tag; tr[id &lt;&lt; 1 | 1].tag += tr[id].tag; tr[id].tag = 0; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://www.zlingfly.com/tags/线段树/"}]},{"title":"不要62","slug":"不要62","date":"2018-01-21T10:56:57.000Z","updated":"2018-05-15T21:28:32.182Z","comments":true,"path":"2018/01/21/不要62/","link":"","permalink":"https://www.zlingfly.com/2018/01/21/不要62/","excerpt":"","text":"题目大意给出数对n、m，计算n，m范围内不是62连号且没有4的数的个数 范围：输入的都是整数对n、m（0&lt;n≤m&lt;1000000） 题解对于这种数据范围很大，但是题目只考虑数字各个数位之间关系的题目，就可以用数位dp解决 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;const int maxn = 100010;const int MOD = (int)1e9+7;typedef long long LL;int dp[20][10];int bit[20];int getans(int n);int dfs(int pos, int st, int limit);int main() &#123; //freopen(\"in.txt\", \"r\", stdin); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; //memset(dp, 0, sizeof(dp)); if (n == 0 &amp;&amp; m == 0)break; cout &lt;&lt; getans(m) - getans(n-1) &lt;&lt; '\\n'; &#125; return 0;&#125;int getans(int n) &#123;//计算[0,n]之间符合题意的个数 int p = 0; while (n) &#123; bit[++p] = n % 10; n /= 10; &#125; int t= dfs(p, 0, 1); //cout &lt;&lt; \"t=\" &lt;&lt; t &lt;&lt; endl; return t;&#125;int dfs(int pos, int st, int limit) &#123; //st保存前一位是否为6 //limit保存当前位是否为最高位 int ans = 0; if (pos == 0) return 1; if (!limit&amp;&amp;dp[pos][st])//记忆化搜索 return dp[pos][st]; int mx = limit ? bit[pos] : 9; for (int i = 0; i &lt;= mx; i++) &#123; if (i == 4)continue; if (st &amp;&amp; i == 2)continue; //去掉不符合题意的数 int t = dfs(pos - 1, i==6, limit&amp;&amp;i == mx); ans += t; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; endl; //cout &lt;&lt; \"ans=\" &lt;&lt; ans &lt;&lt; endl; &#125; if (!limit)dp[pos][st] = ans; return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"数位dp","slug":"数位dp","permalink":"https://www.zlingfly.com/tags/数位dp/"}]},{"title":"windy数","slug":"windy数","date":"2017-12-18T23:31:36.000Z","updated":"2018-05-15T21:28:33.090Z","comments":true,"path":"2017/12/19/windy数/","link":"","permalink":"https://www.zlingfly.com/2017/12/19/windy数/","excerpt":"","text":"题目windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 题解数位dp水题，getans(n)搜索0-n之间的答案，则对于区间[l,r]最后答案为getans(r)-getans(l-1)getans里用dfs对n的每一位进行枚举 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn=1000010;using namespace std;typedef long long LL;const int MOD=(int)(1e9+7);int bit[20],dp[20][10];int getans(int n);int dfs(int pos,int st,int limit,int maxbit);int main()&#123; // freopen(\"in.txt\",\"r\",stdin); //ios::sync_with_stdio(false); int l,r; while(cin&gt;&gt;l&gt;&gt;r)&#123; //cout&lt;&lt;getans(r)&lt;&lt;' '; //cout&lt;&lt;getans(l-1)&lt;&lt;endl; cout&lt;&lt;getans(r)-getans(l-1)&lt;&lt;endl; &#125; return 0;&#125;int getans(int n)&#123; int p=0,ans=0; while(n)&#123; bit[++p]=n%10; n/=10; &#125; return dfs(p,0,1,1);&#125;int dfs(int pos,int st,int limit,int maxbit)&#123; //当前位的前面都为0时maxbit为true if(pos==0) return 1; if(!limit&amp;&amp;!maxbit&amp;&amp;dp[pos][st]) return dp[pos][st]; int mx=limit?bit[pos]:9; int ans=0; for(int i=0;i&lt;=mx;i++)&#123; if(abs(i-st)&lt;2&amp;&amp;!(maxbit))continue; ans+=dfs(pos-1,i,limit&amp;&amp;i==mx,maxbit&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!maxbit)dp[pos][st]=ans; return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"数位dp","slug":"数位dp","permalink":"https://www.zlingfly.com/tags/数位dp/"}]},{"title":"B-number","slug":"B-number","date":"2017-12-18T23:15:32.000Z","updated":"2018-05-15T21:28:33.074Z","comments":true,"path":"2017/12/19/B-number/","link":"","permalink":"https://www.zlingfly.com/2017/12/19/B-number/","excerpt":"","text":"题目A wqb-number, or B-number for short, is a non-negative integer whose decimal form contains the sub- string “13” and can be divided by 13. For example, 130 and 2613 are wqb-numbers, but 143 and 2639 are not. Your task is to calculate how many wqb-numbers from 1 to n for a given integer n. Input Process till EOF. In each line, there is one positive integer n(1 &lt;= n &lt;= 1000000000). Output Print each answer in a single line. Sample Input131002001000 Sample Output1122 题解这是一道数位dp入门题，也是我自己A的第一道数位dp题 用dp[pos][pre][flag][sum]保存一个数的数位，前一位的数，是否存在13子串，是否能被13整除的状态 dfs搜索满足条件的数的个数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn=10010;int bit[20],dp[20][10][2][20];int dfs(int pos,int pre,int flag,int sum,int limit);int getans(int n);int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int l; while(cin&gt;&gt;l)&#123; cout&lt;&lt;getans(l)&lt;&lt;endl; &#125;&#125;int getans(int n)&#123;//搜索0-n符合题意的数的个数 int p=0; while(n)&#123; bit[++p]=n%10; n/=10; &#125; return dfs(p,0,0,0,1);&#125;int dfs(int pos,int pre,int flag,int sum,int limit)&#123;//dfs枚举数的每一位 if(pos==0)&#123; if(flag&amp;&amp;sum==0)&#123; //cout&lt;&lt;\"sum=\"&lt;&lt;sum&lt;&lt;endl; return 1; &#125; else return 0; &#125; if(!limit&amp;&amp;dp[pos][pre][flag][sum]) return dp[pos][pre][flag][sum]; int mx=limit?bit[pos]:9; int ans=0; for(int i=0;i&lt;=mx;i++)&#123; ans+=dfs(pos-1,i,(pre==1&amp;&amp;i==3)||flag,(sum*10+i)%13,limit&amp;&amp;i==mx); //cout&lt;&lt;\"ans=\"&lt;&lt;ans&lt;&lt;endl; &#125; if(!limit)dp[pos][pre][flag][sum]=ans; return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"数位dp","slug":"数位dp","permalink":"https://www.zlingfly.com/tags/数位dp/"}]},{"title":"2017-12-11","slug":"2017-12-11","date":"2017-12-12T22:24:34.000Z","updated":"2018-05-15T21:28:32.965Z","comments":true,"path":"2017/12/13/2017-12-11/","link":"","permalink":"https://www.zlingfly.com/2017/12/13/2017-12-11/","excerpt":"","text":"1,翘了一次金工实习，结果GG了， 2,第一次觉得挂科离我那么近， 3,有一种莫名其妙的害怕说不出来， 4,近两年来，过惯了浑浑噩噩没有起伏的日子，突然发现因为别人感到喜怒哀乐，也没有人为我感到喜怒哀乐。活着，却像死了一样。","categories":[{"name":"diary","slug":"diary","permalink":"https://www.zlingfly.com/categories/diary/"}],"tags":[]},{"title":"骨牌覆盖问题·一","slug":"骨牌覆盖问题·一","date":"2017-12-07T19:05:36.000Z","updated":"2018-05-15T21:28:32.989Z","comments":true,"path":"2017/12/08/骨牌覆盖问题·一/","link":"","permalink":"https://www.zlingfly.com/2017/12/08/骨牌覆盖问题·一/","excerpt":"","text":"问题描述骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？ 题解对于每一个大于2*2的棋盘，都有一下三种情况 通过方法1和方法2，则可以得到f[n]=f[n-1]+f[n-2] 到这里就可以发现题目转化为求斐波那契数列，不过这里范围过大，需要用到矩阵快速幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const int MOD =19999997;typedef long long LL;class matrix&#123;public: LL row,col; LL ele[5][5]; matrix(); void init(); matrix(int r,int c); matrix operator*(matrix x); void show();&#125;;matrix matrix::operator*(matrix x)&#123; int i,j,k; LL t; matrix res(row,x.col); for(i=0;i&lt;row;i++)&#123; for(j=0;j&lt;x.col;j++)&#123; t=0; for(k=0;k&lt;x.col;k++)&#123; t=(t+(ele[i][k]*x.ele[k][j]))%MOD; &#125; res.ele[i][j]=t; &#125; &#125; return res;&#125;//矩阵乘法matrix::matrix()&#123; row=1,col=2; ele[0][0]=0,ele[0][1]=1; ele[1][0]=1,ele[1][1]=1;;&#125;matrix::matrix(int r,int c)&#123; row=r,col=c; ele[0][0]=0,ele[0][1]=1; ele[1][0]=1,ele[1][1]=1;&#125;void matrix::init()&#123;//全部元素初始化为1 row=2,col=2; memset(ele,1,sizeof(ele));&#125;void matrix::show()&#123; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; cout&lt;&lt;ele[i][j]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125;&#125;matrix quick(matrix a,int n);int main()&#123; //freopen(\"in.txt\",\"r\",stdin); //ios::sync_with_stdio(false); matrix a(2,2),b; int n; cin&gt;&gt;n; a=quick(a,n); b=b*a; cout&lt;&lt;b.ele[0][0]&lt;&lt;endl; //b.show(); return 0;&#125;matrix quick(matrix a,int n)&#123;//矩阵快速幂 matrix t(2,2); t.init(); while(n)&#123; if(n&amp;1)t=t*a; a=a*a; n=n&gt;&gt;1; &#125; return t;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://www.zlingfly.com/tags/矩阵快速幂/"}]},{"title":"Chtholly's-request","slug":"Chtholly-s-request","date":"2017-12-04T22:55:46.000Z","updated":"2018-05-15T21:28:32.553Z","comments":true,"path":"2017/12/05/Chtholly-s-request/","link":"","permalink":"https://www.zlingfly.com/2017/12/05/Chtholly-s-request/","excerpt":"","text":"题目B. Chtholly’s requesttime limit per test 2 seconds memory limit per test256 megabytesinputstandard inputoutputstandard output — Thanks a lot for today. — I experienced so many great things. — You gave me memories like dreams… But I have to leave now… — One last request, can you… — Help me solve a Codeforces problem? — …… — What? Chtholly has been thinking about a problem for days: If a number is palindrome and length of its decimal representation without leading zeros is even, we call it a zcy number. A number is palindrome means when written in decimal representation, it contains no leading zeros and reads the same forwards and backwards. For example 12321 and 1221 are palindromes and 123 and 12451 are not. Moreover, 1221 is zcy number and 12321 is not. Given integers k and p, calculate the sum of the k smallest zcy numbers and output this sum modulo p. Unfortunately, Willem isn’t good at solving this kind of problems, so he asks you for help!Input The first line contains two integers k and p (1 ≤ k ≤ 105, 1 ≤ p ≤ 109).Output Output single integer — answer to the problem.Examplesinput 2 100 output 33 input 5 30 output 15 Note In the first example, the smallest zcy number is 11, and the second smallest zcy number is 22. In the second example, . 题解就是找位数是偶数的回文串，我一开始暴力判断每个数是不是回文，结果TLE 题解是 zcy=str+str的回文 从1-k枚举i，对于每个i，i接上i的回文就是一个zcy number，最大枚举到1e5即可 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;const int maxn = 100010;#define MAX 1e10typedef long long LL;long long zcy[100005];LL pow(int a, int n);int main() &#123; //freopen(\"in.txt\", \"r\", stdin); LL k, p, i, j,num[maxn]; cin &gt;&gt; k &gt;&gt; p; LL count = 0,ans=0; for(i = 1; i &lt; maxn-5; i++) &#123; LL t = i, a = 0; int bit = 0; while (t) &#123; a = a * 10 + t % 10; t /= 10; bit++; &#125; t = i*pow(10, bit) + a; num[count++] = t; &#125; for (i = 0; i &lt; k; i++) ans = (ans+num[i])%p; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;LL pow(int a, int n) &#123; LL t = 1; while (n--) &#123; t = t*a; &#125; return t;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://www.zlingfly.com/tags/codeforces/"},{"name":"回文","slug":"回文","permalink":"https://www.zlingfly.com/tags/回文/"}]},{"title":"AOJ.1307 背包装物","slug":"AOJ-1307-背包装物","date":"2017-11-29T21:19:35.000Z","updated":"2018-05-15T21:28:32.486Z","comments":true,"path":"2017/11/30/AOJ-1307-背包装物/","link":"","permalink":"https://www.zlingfly.com/2017/11/30/AOJ-1307-背包装物/","excerpt":"","text":"背包装物运行时限: 2000 ms 单次运行时限: 2000 ms 内存限制: 64 MB 题目描述 Rbb和蕊蕊要出去比赛，他们需要带很多东西，但是他们只有一个背包。为了能够尽可能多带一些重要的东西，现在他们找你来帮忙。为了简化问题，我们将其简化成简单的数学模型。将n个价值为w_i，体积为c_i的物品，放入一个容量为v的背包。显然，我们需要满足Σc_i≤v，同时Σw_i尽可能大。程序输入说明第1行：T。数据组数(0≤n≤10)第1行：n，v。 物品的个数(0≤n≤10)，背包容量（0≤v≤1000000000）第2~n+1行：w_i，c_i。第i个物品的价值(0≤w_i≤1000)和体积(0≤w_i≤100000000)程序输出说明在一行内输出一个整数，表示背包内能装入的物品最大的价值和程序输入样例 1 5 10 1 2 1 3 2 2 2 3 3 4 程序输出样例 7 提示选择第3、4、5个物品 这题我一开始用贪心写了一发，发现有一组数据是卡贪心的，说实话以前一直没注意贪心的缺陷，即用取性价比最高的物品的贪心策略时，对性价比相同而容量不同的物品是无法做出正确的选择的。例如背包容量=30，三个物品c[1]=25,w[1]=25;c[2]=10,w[2]=10;c[3]=20,w[3]=20;程序无法确定到底选择哪个物品，如果选取物品1，肯定是错的。 贪心GG后我试了一下01背包，结果MLE，确实，1e10的容量，即使空间压缩仍然不够。真是刷题少踩坑也不得不服。 我是看了题解才知道是用DFS的，DFS的代码倒是不难，直接枚举每个物品选与不选的情况 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 0;int w[20], c[20],n, v, ans = maxn;void dfs(int i, int j, int res);int main() &#123; //freopen(\"in.txt\", \"r\", stdin); int t; cin &gt;&gt; t; while (t--) &#123; int i,j; ans = 0; memset(w, 0, sizeof(w)); cin &gt;&gt; n&gt;&gt;v; for (i = 1; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; c[i]; dfs(0, v, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;void dfs(int i,int j, int res) &#123; if (i &gt; n) &#123; ans = max(ans, res); return; &#125; dfs(i + 1, j, res); if (j &gt;= c[i + 1]) dfs(i + 1, j - c[i + 1], res + w[i+1]); &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.zlingfly.com/tags/DFS/"}]},{"title":"线性筛素数+区间","slug":"线性筛素数-区间","date":"2017-11-26T22:53:28.000Z","updated":"2018-05-15T21:28:32.475Z","comments":true,"path":"2017/11/27/线性筛素数-区间/","link":"","permalink":"https://www.zlingfly.com/2017/11/27/线性筛素数-区间/","excerpt":"","text":"线性筛法枚举i=2~n,对于每一个i，无论i是质数还是合数，都去枚举i的质数倍，并且当i能被质数整除时停止枚举，这样可以保证每个合数只会被枚举一次，时间复杂度为O(n)。 例题：AOJ 1183:找素数 题目大意是找区间中素数的个数线性筛法可以以较快的速度判断区间内的素数，但是题中给出的数据较大，不能直接开数组，但是区间长度并不大，所以可以将区间移动至下标较小的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1000010;typedef long long LL;LL prime[maxn],p[maxn],vis[maxn];bool isPrime[maxn];int primeCount=0;void make();int main()&#123; //freopen(\"in.txt\",\"r\",stdin); make(); LL a,b; int n=0; scanf(\"%lld %lld\",&amp;a,&amp;b); if(b&lt;maxn)&#123;//当区间下标较小时直接计算 for(int i=a;i&lt;=b;i++) if(isPrime[i]) n++; &#125; else&#123;//否则进行下标移动 memset(vis,1,sizeof(vis)); for(int i=0;i&lt;primeCount;i++)&#123; LL k=a/prime[i]; if(k*prime[i]&lt;a)k++;//求出使prime[i]&gt;=a的最小倍数 for(LL j=k*prime[i];j&lt;=b;j+=prime[i])&#123;//对区间[a,b]进行枚举 vis[j-a]=0;//下标左移a个位置 //质数的k倍必然不是质数 //cout&lt;&lt;j&lt;&lt;endl; &#125; &#125; for(LL i=a;i&lt;=b;i++)&#123; if(vis[i-a]) n++; &#125; &#125; printf(\"%d\\n\",n);&#125;void make()&#123;//线性筛 memset(isPrime,1,sizeof(isPrime)); isPrime[1]=0; for(int i=2;i&lt;maxn;i++)&#123; if(isPrime[i])&#123; prime[primeCount++]=i; &#125; for(int j=0;j&lt;primeCount;j++)&#123; if(i*prime[j]&gt;=maxn)break; isPrime[i*prime[j]]=0; if(i%prime[j]==0)break;//当i能整除质数时停止枚举 &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.zlingfly.com/categories/algorithm/"}],"tags":[{"name":"线性筛","slug":"线性筛","permalink":"https://www.zlingfly.com/tags/线性筛/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2017-11-25T23:25:19.000Z","updated":"2018-05-15T21:28:32.417Z","comments":true,"path":"2017/11/26/KMP算法/","link":"","permalink":"https://www.zlingfly.com/2017/11/26/KMP算法/","excerpt":"","text":"普通的字符串匹配是用模式串与原字符串的每一个字符为起点进行匹配 在匹配发生分歧时，会发现如果存在一个长度k，使得模式串[1, i-k]和[k, i-1]这两段相同，那么可以将对齐点移到k（i为发生分歧的位置）。kmp算法就是通过这样跳转对齐点来缩减计算量，使复杂度接近O(n) 这是一道kmp的模板题hihoCoder1015:kmp算法，里面也有kmp算法的讲解和证明 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn=10010;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int n; cin&gt;&gt;n; while(n--)&#123; string str,par; int next[maxn]=&#123;-1&#125;; cin&gt;&gt;par&gt;&gt;str; int i=0,j=-1,ans=0; //j=-1为对齐点越过发生分歧的位置时的情况 int len=par.size(); //建立next数组 while(i&lt;len)&#123; if(j==-1||par[i]==par[j]) next[++i]=++j; else j=next[j]; &#125; //for(i=0;i&lt;=len;i++) // cout&lt;&lt;next[i]&lt;&lt;' '; //cout&lt;&lt;endl; int lens=str.size(); i=0,j=0; //从0位置开始匹配，当对齐点越过分歧位置以及匹配成功i,j都+1 //当j=模式串长度时完全匹配 while(i&lt;lens)&#123; if(j==-1||str[i]==par[j]) ++i,++j; else j=next[j]; if(j==len)ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.zlingfly.com/categories/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.zlingfly.com/tags/字符串/"},{"name":"KMP","slug":"KMP","permalink":"https://www.zlingfly.com/tags/KMP/"}]},{"title":"2017-11-07","slug":"2017-11-07","date":"2017-11-07T19:59:50.000Z","updated":"2018-05-15T21:28:32.371Z","comments":true,"path":"2017/11/08/2017-11-07/","link":"","permalink":"https://www.zlingfly.com/2017/11/08/2017-11-07/","excerpt":"","text":"今天在实验室看到皓神已经开始收拾东西准备退役，我很高兴他们拿了银牌光荣离开。 但是正如肖申克的救赎中所说，当我们看着自由之鸟飞向天空，我们会真心祝福他们，但是回过头来，却不得不为自己的处境困扰。","categories":[{"name":"diary","slug":"diary","permalink":"https://www.zlingfly.com/categories/diary/"}],"tags":[]},{"title":"Python3模拟登录校园网","slug":"Python3模拟登录校园网","date":"2017-10-23T22:05:05.000Z","updated":"2018-05-15T21:28:32.345Z","comments":true,"path":"2017/10/24/Python3模拟登录校园网/","link":"","permalink":"https://www.zlingfly.com/2017/10/24/Python3模拟登录校园网/","excerpt":"","text":"准备工作 ####要登录校园网，我们首先得看看登录原理是什么。状态判断：如果是已登录状态，该页面跳转至网站首页；否则显示该登录页面。(因为要登录的是校园网，也什么状态可言，肯定是断开状态) 表单填写：前端一个Form，包括账号和密码。 前端判断格式：判断邮箱是否符合邮箱格式、密码是否符合长度等。 表单提交：POST表单。 后台匹配：查找是否存在该用户；匹配该用户密码；返回是否匹配。（我们只管登录，其他不管） 页面跳转：匹配成功，则添加COOKIE保持登录状态；否则提示相关错误，并跳回登录状态。 说了一堆有的没的，听不懂听不懂，反正就是抓取表单数据，然后提交就OK了 问：用什么抓呢？ 答：Fiddle Fiddle安装教程 得到了表单数据，准备工作就完成了 进入正题 本文用的是Python3的urllib库，如果还没有接触过，请查看官方文档稍微了解一下 urllib翻译官方文档,urllib — URL handling modules 123456789101112131415161718192021222324252627282930313233343536373839404142434445from urllib import request,parseheaders=&#123;#设置浏览器代理 'Host': '172.16.253.3:801', 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36', 'Referer': 'http://172.16.253.3/a70.htm?mac=000000000000', &#125;#建立空的openeropener=request.build_opener()#给opener添加header，addheaders接受元组而非字典opener.addheaders=[(key,value) for key,value in headers.items()]def login(username,password): #这里URL是个坑，要的是爬取到的login文件里的url，不是登陆网页的url url='http://172.16.253.3:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=172.16.253.3&amp;iTermType=1&amp;mac=000000000000&amp;ip=172.19.9.155&amp;enAdvert=0&amp;loginMethod=1' #表单数据，通过fiddler抓取 data=&#123; 'c':'ACSetting', 'a':'Login', 'protocol':'http:', 'hostname':'172.16.253.3', 'iTermType':'1', 'mac':'000000000000', 'ip':'172.21.11.17', 'enAdvert':'0', 'loginMethod':'1', 'DDDDD':username, 'upass':password, 'R1':'0', 'R2':'0', 'R6':'0', 'para':'00', 'OMKKey':'123456',&#125; #post数据必须是byte类型 post_data=parse.urlencode(data).encode('utf-8') #打开url，发送表单 r=opener.open(url,post_data) result=r.read() print(result.decode('gbk'))if __name__=='__main__': account='******'#账号 secret='******'#密码 login(account,secret) 运行程序没有错误，能看到登录成功的字样就说明已经登录成功 到这里，模拟登录校园网已经完成，你还可以通过正则表达式或其他Python库来解析返回的网页，也可以添加功能解决诸如异地在线等问题。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.zlingfly.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.zlingfly.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.zlingfly.com/tags/爬虫/"}]},{"title":"关于这个博客","slug":"关于这个博客","date":"2017-10-22T14:13:48.000Z","updated":"2018-05-15T21:28:32.148Z","comments":true,"path":"2017/10/22/关于这个博客/","link":"","permalink":"https://www.zlingfly.com/2017/10/22/关于这个博客/","excerpt":"","text":"一开始的时候，我只是想找个地方记录点东西而已，不然生活太无聊。后来就想到了搭建一个博客，感觉还挺适合我的，一来可以接触些新的东西，二来是觉得有个自己的网站真的是美滋滋啊。 刚搭建好这个博客没有文章，因为不想把原来博客的内容搬过来，原博客的东西多半是我一知半解的代码和算法and我懒。以后再慢慢慢慢慢慢地把我能懂的算法和一些好玩的东西放在这里好了。","categories":[{"name":"diary","slug":"diary","permalink":"https://www.zlingfly.com/categories/diary/"}],"tags":[]}]}